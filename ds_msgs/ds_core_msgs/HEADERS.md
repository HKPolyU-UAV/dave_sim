# Motivation

Many of the data messages generated by a vehicle have common fields.  These often include timestamps, source sensor IDs, and so on.  In order to enforce consistent behavior between message, facilitate dealing with an abstract "message", etc, it helps to define a common message header.  

ROS already defines a common header, std_msg/Header.  Including this message provides access to a number of useful features.  In particular, there are filters and other tools that can match multiple samples by timestamp, grab a transform via tf for a specific sample based on its tf name and timestamp, etc.  All that functionality is very useful, and often a requirement for using standard ROS packages.  

Unfortunately, the common ROS header does not include a few fields we wish it did.  Even worse, ROS provides no provision for custom headers.  The "HasHeader" trait of a particular message is set based on a hard-coded non-recursive check for a std_msg/Header in a message definition.  There is no way around this without hacking on the ROS message generation utilities.

## The Two-Header Solution

Our solution is to include both a standard and a non-standard header.  That's annoying and slightly confusing though, so ALWAYS include a comment block referencing this file.  

# The Part You Copy & Paste

```
# The standard 2-part DsHeader block
# This allows both a standard ROS header and DS-specific header blocks
# See HEADERS.md in ds_core_msgs for details
std_msgs/Header header
ds_core_msgs/DsHeader ds_header
```

## The Standard ROS Header

The standard ROS header has the following definition:

```
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
# 0: no frame
# 1: global frame
string frame_id
```

This documentation is a bit hit-or-miss though, so let's clarify a few points:

* The sequence number is pretty much irrelevant.  Many nodes don't set it correctly anyway, so don't use it for anything.

* The timestamp is the best-guess for the time of the sensor measurement.  This is the time you'll want to use when looking up associated navigation data, etc.  Every sensor driver should make a best-effort to get as accurate a time as practical.

* frame_id is the measurement frame associated with this data.  This is probably the sensor frame.

Remember, the standard header is set up to make it easy to associate a `tf` transform named `frame_id` at time `stamp` with this sample.

## The DsHeader

There were additional fields not in the standard header we wanted to add.  These reside in DsHeader, defined as:

```
# Time data was received or sent out (i/o time)
time io_time

# Sensor source UUID
uint64[2] source_uuid
```

The fields should be well-named, but in the spirit of consistency:

* `io_time` is the time data was received (or sent) by the driver.  It should *always* be measured with ROS Time.

* `source_uuid` is a unique identifier for the originating sensor.  The mechanism of defining this is to be determined.

